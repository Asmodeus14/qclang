// src/codegen/qasm.rs - COMPLETE FIXED VERSION
use crate::qir::{QirModule, QirFunction, QirBlock, QirOp, QirGate, QirValue, QubitId, CbitId, BitState, TempId};
use std::collections::{HashMap, HashSet};

pub struct QASMGenerator {
    qubit_map: HashMap<usize, usize>,        // Map from QubitId to QASM index
    cbit_map: HashMap<usize, usize>,         // Map from CbitId to QASM index
    temp_to_qubit: HashMap<usize, usize>,    // Map from TempId to QubitId
    temp_to_cbit: HashMap<usize, usize>,     // Map from TempId to CbitId
    qubit_allocations: HashSet<usize>,       // Track which qubit IDs have been allocated
    cbit_allocations: HashSet<usize>,        // Track which cbit IDs have been allocated
    gate_count: usize,
    measurement_count: usize,
    max_qubit_id: usize,                     // Track maximum qubit ID used
    max_cbit_id: usize,                      // Track maximum cbit ID used
    used_qubits: HashSet<usize>,             // Qubits actually used in operations
    used_cbits: HashSet<usize>,              // Cbits actually used in operations
    initialization_gates: HashMap<usize, String>, // Qubit initialization gates
}

impl QASMGenerator {
    pub fn new() -> Self {
        Self {
            qubit_map: HashMap::new(),
            cbit_map: HashMap::new(),
            temp_to_qubit: HashMap::new(),
            temp_to_cbit: HashMap::new(),
            qubit_allocations: HashSet::new(),
            cbit_allocations: HashSet::new(),
            gate_count: 0,
            measurement_count: 0,
            max_qubit_id: 0,
            max_cbit_id: 0,
            used_qubits: HashSet::new(),
            used_cbits: HashSet::new(),
            initialization_gates: HashMap::new(),
        }
    }

    pub fn generate(&mut self, module: &QirModule) -> String {
        let mut output = String::new();
        
        self.reset();
        
        output.push_str("// Generated by QCLang Phase 1.5 (QIR-to-QASM)\n");
        output.push_str(&format!("// Module: {}\n", module.name));
        output.push_str("OPENQASM 2.0;\n");
        output.push_str("include \"qelib1.inc\";\n\n");
        
        // First pass: collect all resources
        self.collect_resources(module);
        
        // Generate register declarations
        output.push_str(&format!("qreg q[{}];\n", self.max_qubit_id + 1));
        output.push_str(&format!("creg c[{}];\n\n", self.max_cbit_id + 1));
        
        // Generate initialization gates first
        output.push_str("// Initialization gates\n");
        for i in 0..=self.max_qubit_id {
            if let Some(gate) = self.initialization_gates.get(&i) {
                output.push_str(gate);
            }
        }
        output.push_str("\n");
        
        // Generate code for each function
        for func in &module.functions {
            output.push_str(&self.generate_function(func));
        }
        
        output
    }
    
    pub fn qubit_count(&self) -> usize {
        self.used_qubits.len()
    }
    
    pub fn cbit_count(&self) -> usize {
        self.used_cbits.len()
    }
    
    pub fn gate_count(&self) -> usize {
        self.gate_count
    }
    
    pub fn measurement_count(&self) -> usize {
        self.measurement_count
    }

    fn reset(&mut self) {
        self.qubit_map.clear();
        self.cbit_map.clear();
        self.temp_to_qubit.clear();
        self.temp_to_cbit.clear();
        self.qubit_allocations.clear();
        self.cbit_allocations.clear();
        self.gate_count = 0;
        self.measurement_count = 0;
        self.max_qubit_id = 0;
        self.max_cbit_id = 0;
        self.used_qubits.clear();
        self.used_cbits.clear();
        self.initialization_gates.clear();
    }
    
    fn collect_resources(&mut self, module: &QirModule) {
        // Collect from global resources
        for qubit in &module.global_qubits {
            self.register_qubit(qubit.id());
        }
        
        for cbit in &module.global_cbits {
            self.register_cbit(cbit.id());
        }
        
        // Collect from each function
        for func in &module.functions {
            self.collect_function_resources(func);
        }
    }
    
    fn collect_function_resources(&mut self, func: &QirFunction) {
        // Track the next temp ID for this function
        let mut temp_counter = 0;
        
        for (_, block) in &func.blocks {
            for op in &block.ops {
                match op {
                    QirOp::AllocQubit { result, init_state } => {
                        // Create a new qubit ID
                        let qubit_id = self.qubit_allocations.len();
                        self.qubit_allocations.insert(qubit_id);
                        
                        // Map temp to qubit
                        self.temp_to_qubit.insert(result.id(), qubit_id);
                        
                        // Track max qubit ID
                        if qubit_id > self.max_qubit_id {
                            self.max_qubit_id = qubit_id;
                        }
                        
                        // Store initialization gate if needed
                        if let Some(BitState::One) = init_state {
                            self.initialization_gates.insert(
                                qubit_id,
                                format!("x q[{}]; // Initialize |1>\n", qubit_id)
                            );
                        }
                    }
                    QirOp::AllocCbit { result, init_value } => {
                        // Create a new cbit ID
                        let cbit_id = self.cbit_allocations.len();
                        self.cbit_allocations.insert(cbit_id);
                        
                        // Map temp to cbit
                        self.temp_to_cbit.insert(result.id(), cbit_id);
                        
                        // Track max cbit ID
                        if cbit_id > self.max_cbit_id {
                            self.max_cbit_id = cbit_id;
                        }
                        
                        // Store initialization if needed
                        if let Some(1) = init_value {
                            // Note: Classical initialization not in QASM, just comment
                        }
                    }
                    QirOp::ApplyGate { args, .. } => {
                        for arg in args {
                            self.collect_qubit_from_value(arg);
                        }
                    }
                    QirOp::Measure { qubit, cbit } => {
                        let qubit_id = qubit.id();
                        let cbit_id = cbit.id();
                        
                        // Register qubit and cbit
                        self.register_qubit(qubit_id);
                        self.register_cbit(cbit_id);
                    }
                    _ => {}
                }
            }
        }
    }
    
    fn collect_qubit_from_value(&mut self, value: &QirValue) {
        match value {
            QirValue::Qubit(qubit_id) => {
                self.register_qubit(qubit_id.id());
            }
            QirValue::Temp(temp_id) => {
                // Try to find if this temp holds a qubit
                if let Some(qubit_id) = self.temp_to_qubit.get(&temp_id.id()) {
                    self.register_qubit(*qubit_id);
                }
            }
            _ => {}
        }
    }
    
    fn register_qubit(&mut self, qubit_id: usize) {
        // Mark as used
        self.used_qubits.insert(qubit_id);
        
        // Track max
        if qubit_id > self.max_qubit_id {
            self.max_qubit_id = qubit_id;
        }
    }
    
    fn register_cbit(&mut self, cbit_id: usize) {
        // Mark as used
        self.used_cbits.insert(cbit_id);
        
        // Track max
        if cbit_id > self.max_cbit_id {
            self.max_cbit_id = cbit_id;
        }
    }
    
    fn generate_function(&mut self, func: &QirFunction) -> String {
        let mut output = String::new();
        
        output.push_str(&format!("// Function: {}\n", func.name));
        
        // Process blocks in order
        let mut block_ids: Vec<_> = func.blocks.keys().collect();
        block_ids.sort_by_key(|id| id.id());
        
        for block_id in block_ids {
            if let Some(block) = func.blocks.get(block_id) {
                if !block.ops.is_empty() {
                    output.push_str(&format!("  // Block {}\n", block_id.id()));
                    output.push_str(&self.generate_block(block));
                }
            }
        }
        
        output.push_str("\n");
        output
    }

    fn generate_block(&mut self, block: &QirBlock) -> String {
        let mut output = String::new();
        
        for op in &block.ops {
            let op_str = self.generate_op(op);
            if !op_str.is_empty() {
                output.push_str(&format!("  {}", op_str));
            }
        }
        
        output
    }

// In qasm.rs - Update the generate_op function
fn generate_op(&mut self, op: &QirOp) -> String {
    match op {
        QirOp::AllocQubit { result: _, init_state: _ } => {
            // Already handled in initialization_gates
            String::new()
        }
        
        QirOp::ApplyGate { gate, args, result: _ } => {
            self.generate_gate(gate, args)
        }
        
        QirOp::Measure { qubit, cbit } => {
            self.generate_measurement(*qubit, *cbit)
        }
        
        QirOp::AllocCbit { result: _, init_value: _ } => {
            // Already handled in resource collection
            String::new()
        }
        
        QirOp::Comment(text) => {
            format!("// {}\n", text)
        }
        
        // For all other operations, return empty string (don't generate comments)
        _ => String::new(),
    }
}
    
    fn get_qubit_index(&self, value: &QirValue) -> Option<usize> {
        match value {
            QirValue::Qubit(qubit_id) => {
                Some(qubit_id.id())
            }
            QirValue::Temp(temp_id) => {
                self.temp_to_qubit.get(&temp_id.id()).copied()
            }
            _ => None
        }
    }
    
    fn get_cbit_index(&self, value: &QirValue) -> Option<usize> {
        match value {
            QirValue::Cbit(cbit_id) => {
                Some(cbit_id.id())
            }
            QirValue::Temp(temp_id) => {
                self.temp_to_cbit.get(&temp_id.id()).copied()
            }
            _ => None
        }
    }
    
    fn generate_gate(&mut self, gate: &QirGate, args: &[QirValue]) -> String {
        // Extract qubit indices from arguments
        let mut qubit_indices = Vec::new();
        
        for arg in args {
            if let Some(idx) = self.get_qubit_index(arg) {
                qubit_indices.push(idx);
                self.used_qubits.insert(idx);
            }
        }
        
        if qubit_indices.is_empty() {
            return String::new();
        }
        
        let gate_str = match gate {
            QirGate::H => {
                self.gate_count += 1;
                format!("h q[{}];\n", qubit_indices[0])
            }
            QirGate::X => {
                self.gate_count += 1;
                format!("x q[{}];\n", qubit_indices[0])
            }
            QirGate::Y => {
                self.gate_count += 1;
                format!("y q[{}];\n", qubit_indices[0])
            }
            QirGate::Z => {
                self.gate_count += 1;
                format!("z q[{}];\n", qubit_indices[0])
            }
            QirGate::T => {
                self.gate_count += 1;
                format!("t q[{}];\n", qubit_indices[0])
            }
            QirGate::S => {
                self.gate_count += 1;
                format!("s q[{}];\n", qubit_indices[0])
            }
            QirGate::RX(angle) => {
                self.gate_count += 1;
                format!("rx({}) q[{}];\n", angle, qubit_indices[0])
            }
            QirGate::RY(angle) => {
                self.gate_count += 1;
                format!("ry({}) q[{}];\n", angle, qubit_indices[0])
            }
            QirGate::RZ(angle) => {
                self.gate_count += 1;
                format!("rz({}) q[{}];\n", angle, qubit_indices[0])
            }
            QirGate::CNOT => {
                if qubit_indices.len() >= 2 {
                    self.gate_count += 1;
                    format!("cx q[{}], q[{}];\n", qubit_indices[0], qubit_indices[1])
                } else {
                    String::new()
                }
            }
            QirGate::SWAP => {
                if qubit_indices.len() >= 2 {
                    self.gate_count += 3;
                    format!("cx q[{}], q[{}];\ncx q[{}], q[{}];\ncx q[{}], q[{}]; // SWAP\n", 
                           qubit_indices[0], qubit_indices[1], 
                           qubit_indices[1], qubit_indices[0], 
                           qubit_indices[0], qubit_indices[1])
                } else {
                    String::new()
                }
            }
            QirGate::Toffoli => {
                if qubit_indices.len() >= 3 {
                    self.gate_count += 1;
                    format!("ccx q[{}], q[{}], q[{}];\n", 
                           qubit_indices[0], qubit_indices[1], qubit_indices[2])
                } else {
                    String::new()
                }
            }
            QirGate::U3(theta, phi, lambda) => {
                self.gate_count += 1;
                format!("u3({}, {}, {}) q[{}];\n", theta, phi, lambda, qubit_indices[0])
            }
            _ => {
                format!("// Unsupported gate: {:?} on qubits {:?}\n", gate, qubit_indices)
            }
        };
        
        gate_str
    }
    
    fn generate_measurement(&mut self, qubit: QubitId, cbit: CbitId) -> String {
        let qubit_idx = qubit.id();
        let cbit_idx = cbit.id();
        
        // Mark as used
        self.used_qubits.insert(qubit_idx);
        self.used_cbits.insert(cbit_idx);
        
        // Track maximums
        if qubit_idx > self.max_qubit_id {
            self.max_qubit_id = qubit_idx;
        }
        if cbit_idx > self.max_cbit_id {
            self.max_cbit_id = cbit_idx;
        }
        
        self.measurement_count += 1;
        format!("measure q[{}] -> c[{}];\n", qubit_idx, cbit_idx)
    }
}