{"$message_type":"diagnostic","message":"file not found for module `type_checker`","code":{"code":"E0583","explanation":"A file wasn't found for an out-of-line module.\n\nErroneous code example:\n\n```compile_fail,E0583\nmod file_that_doesnt_exist; // error: file not found for module\n\nfn main() {}\n```\n\nPlease be sure that a file corresponding to the module exists. If you\nwant to use a module named `file_that_doesnt_exist`, you need to have a file\nnamed `file_that_doesnt_exist.rs` or `file_that_doesnt_exist/mod.rs` in the\nsame directory.\n"},"level":"error","spans":[{"file_name":"src/semantics/mod.rs","byte_start":24,"byte_end":41,"line_start":2,"line_end":2,"column_start":1,"column_end":18,"is_primary":true,"text":[{"text":"mod type_checker;","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"to create the module `type_checker`, create file \"src/semantics/type_checker.rs\" or \"src/semantics/type_checker/mod.rs\"","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"if there is a `mod type_checker` elsewhere in the crate already, import it with `use crate::...` instead","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0583]\u001b[0m\u001b[1m: file not found for module `type_checker`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/mod.rs:2:1\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m mod type_checker;\n  \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: to create the module `type_checker`, create file \"src/semantics/type_checker.rs\" or \"src/semantics/type_checker/mod.rs\"\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: if there is a `mod type_checker` elsewhere in the crate already, import it with `use crate::...` instead\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `tokenize` in module `lexer`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":483,"byte_end":491,"line_start":23,"line_end":23,"column_start":29,"column_end":37,"is_primary":true,"text":[{"text":"        let tokens = lexer::tokenize(source)?;","highlight_start":29,"highlight_end":37}],"label":"not found in `lexer`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `tokenize` in module `lexer`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:23:29\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let tokens = lexer::tokenize(source)?;\n   \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `lexer`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `generate` in module `ir`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":784,"byte_end":792,"line_start":33,"line_end":33,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"        let ir = ir::generate(&program)?;","highlight_start":22,"highlight_end":30}],"label":"not found in `ir`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `generate` in module `ir`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:33:22\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let ir = ir::generate(&program)?;\n   \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `ir`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function `generate` in module `codegen::qasm`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/lib.rs","byte_start":878,"byte_end":886,"line_start":36,"line_end":36,"column_start":35,"column_end":43,"is_primary":true,"text":[{"text":"        let qasm = codegen::qasm::generate(&ir)?;","highlight_start":35,"highlight_end":43}],"label":"not found in `codegen::qasm`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function `generate` in module `codegen::qasm`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/lib.rs:36:35\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let qasm = codegen::qasm::generate(&ir)?;\n   \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `codegen::qasm`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `QReg` found for enum `ast::Type` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":2003,"byte_end":2007,"line_start":67,"line_end":67,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"            Type::Qubit | Type::QReg(_) => true,","highlight_start":33,"highlight_end":37}],"label":"variant or associated item not found in `ast::Type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast.rs","byte_start":36,"byte_end":49,"line_start":2,"line_end":2,"column_start":1,"column_end":14,"is_primary":false,"text":[{"text":"pub enum Type {","highlight_start":1,"highlight_end":14}],"label":"variant or associated item `QReg` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":2003,"byte_end":2007,"line_start":67,"line_end":67,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"            Type::Qubit | Type::QReg(_) => true,","highlight_start":33,"highlight_end":37}],"label":null,"suggested_replacement":"Qreg","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `QReg` found for enum `ast::Type` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:67:33\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Type::Qubit | Type::QReg(_) => true,\n   \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `ast::Type`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/ast.rs:2:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Type {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `QReg` not found for this enum\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a variant with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[91m- \u001b[0m            Type::Qubit | Type::\u001b[91mQReg\u001b[0m(_) => true,\n\u001b[1m\u001b[94m67\u001b[0m \u001b[92m+ \u001b[0m            Type::Qubit | Type::\u001b[92mQreg\u001b[0m(_) => true,\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `1` on type `&ast::Param`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":2161,"byte_end":2162,"line_start":71,"line_end":71,"column_start":39,"column_end":40,"is_primary":true,"text":[{"text":"                    if matches!(param.1, Type::Qubit | Type::QReg(_)) {","highlight_start":39,"highlight_end":40}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `name`, `ty`, `mutable`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `1` on type `&ast::Param`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:71:39\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if matches!(param.1, Type::Qubit | Type::QReg(_)) {\n   \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `name`, `ty`, `mutable`\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `QReg` found for enum `ast::Type` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":2184,"byte_end":2188,"line_start":71,"line_end":71,"column_start":62,"column_end":66,"is_primary":true,"text":[{"text":"                    if matches!(param.1, Type::Qubit | Type::QReg(_)) {","highlight_start":62,"highlight_end":66}],"label":"variant or associated item not found in `ast::Type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast.rs","byte_start":36,"byte_end":49,"line_start":2,"line_end":2,"column_start":1,"column_end":14,"is_primary":false,"text":[{"text":"pub enum Type {","highlight_start":1,"highlight_end":14}],"label":"variant or associated item `QReg` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":2184,"byte_end":2188,"line_start":71,"line_end":71,"column_start":62,"column_end":66,"is_primary":true,"text":[{"text":"                    if matches!(param.1, Type::Qubit | Type::QReg(_)) {","highlight_start":62,"highlight_end":66}],"label":null,"suggested_replacement":"Qreg","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `QReg` found for enum `ast::Type` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:71:62\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     if matches!(param.1, Type::Qubit | Type::QReg(_)) {\n   \u001b[1m\u001b[94m|\u001b[0m                                                              \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `ast::Type`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/ast.rs:2:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Type {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `QReg` not found for this enum\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a variant with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m71\u001b[0m \u001b[91m- \u001b[0m                    if matches!(param.1, Type::Qubit | Type::\u001b[91mQReg\u001b[0m(_)) {\n\u001b[1m\u001b[94m71\u001b[0m \u001b[92m+ \u001b[0m                    if matches!(param.1, Type::Qubit | Type::\u001b[92mQreg\u001b[0m(_)) {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `CBit` found for enum `ast::Type` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":3066,"byte_end":3070,"line_start":94,"line_end":94,"column_start":27,"column_end":31,"is_primary":true,"text":[{"text":"                    Type::CBit => {","highlight_start":27,"highlight_end":31}],"label":"variant or associated item not found in `ast::Type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast.rs","byte_start":36,"byte_end":49,"line_start":2,"line_end":2,"column_start":1,"column_end":14,"is_primary":false,"text":[{"text":"pub enum Type {","highlight_start":1,"highlight_end":14}],"label":"variant or associated item `CBit` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a variant with a similar name","code":null,"level":"help","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":3066,"byte_end":3070,"line_start":94,"line_end":94,"column_start":27,"column_end":31,"is_primary":true,"text":[{"text":"                    Type::CBit => {","highlight_start":27,"highlight_end":31}],"label":null,"suggested_replacement":"Cbit","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `CBit` found for enum `ast::Type` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:94:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     Type::CBit => {\n   \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `ast::Type`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m::: \u001b[0msrc/ast.rs:2:1\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Type {\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `CBit` not found for this enum\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a variant with a similar name\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m94\u001b[0m \u001b[91m- \u001b[0m                    Type::\u001b[91mCBit\u001b[0m => {\n\u001b[1m\u001b[94m94\u001b[0m \u001b[92m+ \u001b[0m                    Type::\u001b[92mCbit\u001b[0m => {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no variant or associated item named `Void` found for enum `ast::Type` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":10294,"byte_end":10298,"line_start":262,"line_end":262,"column_start":42,"column_end":46,"is_primary":true,"text":[{"text":"            if func.return_type == Type::Void {","highlight_start":42,"highlight_end":46}],"label":"variant or associated item not found in `ast::Type`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/ast.rs","byte_start":36,"byte_end":49,"line_start":2,"line_end":2,"column_start":1,"column_end":14,"is_primary":false,"text":[{"text":"pub enum Type {","highlight_start":1,"highlight_end":14}],"label":"variant or associated item `Void` not found for this enum","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no variant or associated item named `Void` found for enum `ast::Type` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:262:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m262\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             if func.return_type == Type::Void {\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mvariant or associated item not found in `ast::Type`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/ast.rs:2:1\n    \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m2\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub enum Type {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m-------------\u001b[0m \u001b[1m\u001b[94mvariant or associated item `Void` not found for this enum\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `context`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":11733,"byte_end":11740,"line_start":299,"line_end":299,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"    fn consume_qubit(&mut self, name: &str, context: &str) -> Result<(), Vec<String>> {","highlight_start":45,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/semantics/ownership_checker.rs","byte_start":11733,"byte_end":11740,"line_start":299,"line_end":299,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"    fn consume_qubit(&mut self, name: &str, context: &str) -> Result<(), Vec<String>> {","highlight_start":45,"highlight_end":52}],"label":null,"suggested_replacement":"_context","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `context`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/semantics/ownership_checker.rs:299:45\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m299\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     fn consume_qubit(&mut self, name: &str, context: &str) -> Result<(), Vec<String>> {\n    \u001b[1m\u001b[94m|\u001b[0m                                             \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_context`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 9 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 9 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0425, E0583, E0599, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0425, E0583, E0599, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0425`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0425`.\u001b[0m\n"}
